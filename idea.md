## 提出的混合方法：有界中点椭圆扫描（BMES）



综合上述分析，`AccuTile` 算法虽精确但计算密集且对GPU并行不友好；多边形近似法虽简单但牺牲了至关重要的准确性。为了寻求一个兼具准确性与高效性的解决方案，本节提出一种新颖的混合算法——有界中点椭圆扫描（Bounded Midpoint Ellipse Scan, BMES）。该算法将 `SnugBox` 的高效包围盒计算与经过改造的中点椭圆算法相结合，旨在实现与 `AccuTile` 同等的剔除精度，同时大幅降低计算成本并优化GPU并行效率。



### 3.1. 算法提案

BMES算法的执行分为两个核心阶段：粗略的包围盒界定和精细的整数扫描。

**第一阶段：使用 `SnugBox` 进行粗略剔除** 

对于每一个需要处理的高斯基元，首先调用《Speedy-Splat》中提出的 `SnugBox` 算法 。  

`SnugBox` 通过一次性的解析计算（包含少量 `sqrt` 运算），为投影到2D空间的椭圆确定一个紧凑的、轴对齐的包围盒（AABB）。这个计算是常数时间的，其成本在每个高斯基元上仅发生一次，而非在每个分块行上重复发生。  

这个AABB的作用是提供一个最小化的、保守的分块搜索空间。只有完全或部分落在这个包围盒内的分块行和分块列，才有可能与椭圆相交。通过这一步，可以预先剔除掉大量无关的分块，极大地缩小了下一阶段精细扫描的工作范围。

**第二阶段：使用中点椭圆扫描进行精细剔除** 在 `SnugBox` 界定的范围内，BMES算法将对每个相关的分块行（tile row）独立地执行一次精细扫描，以确定该行内被椭圆精确覆盖的分块区间 `[x_min_tile, x_max_tile]`。这一过程是BMES的核心创新，它将经典的中点椭圆算法进行了现代化改造，使其适应于并行化的剔除任务而非像素绘制。

1. **并行结构**：可以为 `SnugBox` 确定的每一个分块行（或一组行）分配一个GPU线程（或一个线程组）。由于各行之间的计算是完全独立的，因此该结构天然地适合大规模并行。

2. **整数决策函数**：对于轴对齐的椭圆，其标准方程为 $b^2 x^2+ a^2y^2 - a^2b^2 = 0$。对于任意旋转的椭圆，其方程可以表示为更通用的二次型 $F(x,y)=Ax^2+2Bxy+Cy^2+D′x+E′y+F′=0$。为了完全使用整数运算，可以对该方程进行缩放，得到一个等价的整数形式 $F_{int} (x,y)=0$ 。这个函数   

   $F_{int}(x,y)$ 的符号（正、负、零）可以判断一个点 $(x,y)$ 是在椭圆外、椭圆内还是在椭圆上。

3. **增量式扫描**：对于给定的一个分块行，其上下边界对应两个固定的 $y$ 坐标，$y_{top}$ 和 $y_{bottom}$。算法的目标是找到椭圆与这两条水平线相交的x坐标。以 $y_{top}$ 为例，可以将 $y=y_{top}$ 代入整数决策函数 $F_{int} (x,y)$，得到一个关于x的一元二次方程。中点椭圆算法的精髓在于，它不需要直接求解这个方程。而是从包围盒的边界开始，沿着x轴以一个像素（或一个分块）的步长进行扫描，通过**增量式地更新一个整数决策变量**来判断当前位置是在椭圆内部还是外部。当决策变量的符号发生变化时，即找到了椭圆的边界。这个过程在内循环中只涉及整数加减法和比较，完全避免了 `sqrt` 和浮点运算 。  

   

通过对分块行的上下边界分别执行此扫描，即可精确找到该行内椭圆覆盖的左右x坐标范围，进而确定所有被覆盖的分块。



### 3.3. CUDA实现策略



为了在GPU上高效实现BMES，可以设计如下的CUDA核函数：

**核函数启动配置**： 启动一个CUDA核函数，其网格（grid）大小与场景中的高斯基元总数相对应。每个线程块（thread block）可以负责处理一批高斯基元，例如128或256个。

**线程执行逻辑（伪代码）**：

```c++
__global__ void bmes_culling_kernel(Gaussian* gaussians, Tile* output_tile_list, int* output_counts) {
    int g_idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (g_idx >= num_gaussians) return;

    // 1. 加载高斯参数
    Gaussian g = gaussians[g_idx];
    
    // 2. 阶段一：执行SnugBox计算，获取AABB
    // 此处包含每个高斯一次的少量sqrt和浮点计算
    BoundingBox aabb = compute_snugbox(g);
    int min_ty = aabb.min_y / TILE_HEIGHT;
    int max_ty = aabb.max_y / TILE_HEIGHT;
    
    // 3. 阶段二：遍历AABB内的分块行
    for (int y_row = min_ty; y_row <= max_ty; ++y_row) {
        // 3a. 初始化中点椭圆扫描的整数参数
        // 基于椭圆二次型 F_int(x,y) 和当前 y_row
        IntegerScanState scanner = initialize_midpoint_scanner(g, y_row);
        
        // 3b. 执行增量式扫描找到x方向的范围
        // 这是一个短小的、纯整数运算的顺序循环
        int x_start_tile, x_end_tile;
        find_x_extents(&scanner, aabb.min_x, aabb.max_x, &x_start_tile, &x_end_tile);
        
        // 3c. 输出结果
        // 将该行内所有被覆盖的分块ID和深度写入输出列表
        for (int x_tile = x_start_tile; x_tile <= x_end_tile; ++x_tile) {
            int tile_id = y_row * TILES_PER_ROW + x_tile;
            // 使用原子操作或后续的并行前缀和来管理输出索引
            append_to_output(tile_id, g.depth, output_tile_list, output_counts);
        }
    }
}
```

**并行性分析**：

- **高斯级并行**：整个算法在最高层级上是按高斯基元并行的，每个线程独立处理一个高斯基元，不存在线程间依赖。
- **分块行级并行**：在每个线程内部，对分块行的处理是顺序的。但由于不同线程处理不同的高斯基元，从整个GPU的角度看，无数个分块行的扫描正在并行发生。
- **内循环效率**：`find_x_extents` 函数虽然是顺序的，但其循环次数受限于单个高斯基元在x方向上跨越的分块数，通常是一个很小的值。更重要的是，其内部只包含最高效的整数运算，使得这段顺序代码的执行时间极短。

这种设计巧妙地将顺序依赖性限制在了一个极小的、计算成本极低的工作单元内，从而使得整个算法能够充分利用GPU的大规模并行能力，同时享受到整数运算带来的高效率。